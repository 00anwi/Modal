{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./Blazored.Modal.ts","webpack:///./FocusTrap.ts","webpack:///./node_modules/tabbable/index.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb;AACA;AACA,kBAAkB,mBAAO,CAAC,mCAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,wBAAwB;AACxB;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;ACjBa;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,kDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,gCAAgC,yDAAyD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAuD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,uBAAuB;AACpC;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA","file":"blazored.modal.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./Blazored.Modal.ts\");\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.BlazoredModal = void 0;\r\nvar FocusTrap_1 = require(\"./FocusTrap\");\r\nvar BlazoredModal = /** @class */ (function () {\r\n    function BlazoredModal() {\r\n    }\r\n    /**\r\n     * setFocusTrap\r\n     */\r\n    BlazoredModal.prototype.setFocusTrap = function (element) {\r\n        var trap = new FocusTrap_1[\"default\"](element, {});\r\n        trap.activate({});\r\n    };\r\n    return BlazoredModal;\r\n}());\r\nexports.BlazoredModal = BlazoredModal;\r\nwindow.BlazoredModal = new BlazoredModal();\r\n","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nexports.__esModule = true;\r\nvar tabbable_1 = require(\"tabbable\");\r\nvar activeFocusDelay;\r\nvar activeFocusTraps = (function () {\r\n    var trapQueue = [];\r\n    return {\r\n        activateTrap: function (trap) {\r\n            if (trapQueue.length > 0) {\r\n                var activeTrap = trapQueue[trapQueue.length - 1];\r\n                if (activeTrap !== trap) {\r\n                    activeTrap.pause();\r\n                }\r\n            }\r\n            var trapIndex = trapQueue.indexOf(trap);\r\n            if (trapIndex === -1) {\r\n                trapQueue.push(trap);\r\n            }\r\n            else {\r\n                // move this existing trap to the front of the queue\r\n                trapQueue.splice(trapIndex, 1);\r\n                trapQueue.push(trap);\r\n            }\r\n        },\r\n        deactivateTrap: function (trap) {\r\n            var trapIndex = trapQueue.indexOf(trap);\r\n            if (trapIndex !== -1) {\r\n                trapQueue.splice(trapIndex, 1);\r\n            }\r\n            if (trapQueue.length > 0) {\r\n                trapQueue[trapQueue.length - 1].unpause();\r\n            }\r\n        }\r\n    };\r\n})();\r\nvar FocusTrap = /** @class */ (function () {\r\n    function FocusTrap(element, userOptions) {\r\n        this.doc = document;\r\n        this.container = typeof element === \"string\" ? this.doc.querySelector(element) : element;\r\n        this.config = __assign({ returnFocusOnDeactivate: true, escapeDeactivates: true }, userOptions);\r\n        this.state = {\r\n            firstTabbableNode: null,\r\n            lastTabbableNode: null,\r\n            nodeFocusedBeforeActivation: null,\r\n            mostRecentlyFocusedNode: null,\r\n            active: false,\r\n            paused: false\r\n        };\r\n        this.trap = {\r\n            activate: this.activate,\r\n            deactivate: this.deactivate,\r\n            pause: this.pause,\r\n            unpause: this.unpause\r\n        };\r\n    }\r\n    FocusTrap.prototype.activate = function (activateOptions) {\r\n        if (this.state.active)\r\n            return;\r\n        this.updateTabbableNodes();\r\n        this.state.active = true;\r\n        this.state.paused = false;\r\n        this.state.nodeFocusedBeforeActivation = this.doc.activeElement;\r\n        var onActivate = activateOptions && activateOptions.onActivate\r\n            ? activateOptions.onActivate\r\n            : this.config.onActivate;\r\n        if (onActivate) {\r\n            onActivate();\r\n        }\r\n        this.addListeners();\r\n        return this.trap;\r\n    };\r\n    FocusTrap.prototype.deactivate = function (deactivateOptions) {\r\n        if (!this.state.active)\r\n            return;\r\n        clearTimeout(activeFocusDelay);\r\n        this.removeListeners();\r\n        this.state.active = false;\r\n        this.state.paused = false;\r\n        activeFocusTraps.deactivateTrap(this.trap);\r\n        var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined\r\n            ? deactivateOptions.onDeactivate\r\n            : this.config.onDeactivate;\r\n        if (onDeactivate) {\r\n            onDeactivate();\r\n        }\r\n        var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined\r\n            ? deactivateOptions.returnFocus\r\n            : this.config.returnFocusOnDeactivate;\r\n        if (returnFocus) {\r\n            this.delay(function () {\r\n                this.tryFocus(this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation));\r\n            });\r\n        }\r\n        return this.trap;\r\n    };\r\n    FocusTrap.prototype.pause = function () {\r\n        if (this.state.paused || !this.state.active)\r\n            return;\r\n        this.state.paused = true;\r\n        this.removeListeners();\r\n    };\r\n    FocusTrap.prototype.unpause = function () {\r\n        if (!this.state.paused || !this.state.active)\r\n            return;\r\n        this.state.paused = false;\r\n        this.updateTabbableNodes();\r\n        this.addListeners();\r\n    };\r\n    FocusTrap.prototype.addListeners = function () {\r\n        if (!this.state.active)\r\n            return;\r\n        // There can be only one listening focus trap at a time\r\n        activeFocusTraps.activateTrap(this.trap);\r\n        // Delay ensures that the focused element doesn't capture the event\r\n        // that caused the focus trap activation.\r\n        activeFocusDelay = this.delay(function () {\r\n            this.tryFocus(this.getInitialFocusNode());\r\n        });\r\n        this.doc.addEventListener('focusin', this.checkFocusIn, true);\r\n        this.doc.addEventListener('mousedown', this.checkPointerDown, {\r\n            capture: true,\r\n            passive: false\r\n        });\r\n        this.doc.addEventListener('touchstart', this.checkPointerDown, {\r\n            capture: true,\r\n            passive: false\r\n        });\r\n        this.doc.addEventListener('click', this.checkClick, {\r\n            capture: true,\r\n            passive: false\r\n        });\r\n        this.doc.addEventListener('keydown', this.checkKey, {\r\n            capture: true,\r\n            passive: false\r\n        });\r\n        return this.trap;\r\n    };\r\n    FocusTrap.prototype.removeListeners = function () {\r\n        if (!this.state.active)\r\n            return;\r\n        this.doc.removeEventListener('focusin', this.checkFocusIn, true);\r\n        this.doc.removeEventListener('mousedown', this.checkPointerDown, true);\r\n        this.doc.removeEventListener('touchstart', this.checkPointerDown, true);\r\n        this.doc.removeEventListener('click', this.checkClick, true);\r\n        this.doc.removeEventListener('keydown', this.checkKey, true);\r\n        return this.trap;\r\n    };\r\n    FocusTrap.prototype.getNodeForOption = function (optionName) {\r\n        var optionValue = this.config[optionName];\r\n        var node = optionValue;\r\n        if (!optionValue) {\r\n            return null;\r\n        }\r\n        if (typeof optionValue === 'string') {\r\n            node = this.doc.querySelector(optionValue);\r\n            if (!node) {\r\n                throw new Error('`' + optionName + '` refers to no known node');\r\n            }\r\n        }\r\n        if (typeof optionValue === 'function') {\r\n            node = optionValue();\r\n            if (!node) {\r\n                throw new Error('`' + optionName + '` did not return a node');\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    FocusTrap.prototype.getInitialFocusNode = function () {\r\n        var node;\r\n        if (this.getNodeForOption('initialFocus') !== null) {\r\n            node = this.getNodeForOption('initialFocus');\r\n        }\r\n        else if (this.container.contains(this.doc.activeElement)) {\r\n            node = this.doc.activeElement;\r\n        }\r\n        else {\r\n            node = this.state.firstTabbableNode || this.getNodeForOption('fallbackFocus');\r\n        }\r\n        if (!node) {\r\n            throw new Error('Your focus-trap needs to have at least one focusable element');\r\n        }\r\n        return node;\r\n    };\r\n    FocusTrap.prototype.getReturnFocusNode = function (previousActiveElement) {\r\n        var node = this.getNodeForOption('setReturnFocus');\r\n        return node ? node : previousActiveElement;\r\n    };\r\n    // This needs to be done on mousedown and touchstart instead of click\r\n    // so that it precedes the focus event.\r\n    FocusTrap.prototype.checkPointerDown = function (e) {\r\n        if (this.container.contains(e.target))\r\n            return;\r\n        if (this.config.clickOutsideDeactivates) {\r\n            this.deactivate({\r\n                returnFocus: !tabbable_1[\"default\"].isFocusable(e.target)\r\n            });\r\n            return;\r\n        }\r\n        // This is needed for mobile devices.\r\n        // (If we'll only let `click` events through,\r\n        // then on mobile they will be blocked anyways if `touchstart` is blocked.)\r\n        if (this.config.allowOutsideClick && this.config.allowOutsideClick(e)) {\r\n            return;\r\n        }\r\n        e.preventDefault();\r\n    };\r\n    // In case focus escapes the trap for some strange reason, pull it back in.\r\n    FocusTrap.prototype.checkFocusIn = function (e) {\r\n        // In Firefox when you Tab out of an iframe the Document is briefly focused.\r\n        if (this.container.contains(e.target) || e.target instanceof Document) {\r\n            return;\r\n        }\r\n        e.stopImmediatePropagation();\r\n        this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\r\n    };\r\n    FocusTrap.prototype.checkKey = function (e) {\r\n        if (this.config.escapeDeactivates !== false && this.isEscapeEvent(e)) {\r\n            e.preventDefault();\r\n            this.deactivate();\r\n            return;\r\n        }\r\n        if (this.isTabEvent(e)) {\r\n            this.checkTab(e);\r\n            return;\r\n        }\r\n    };\r\n    // Hijack Tab events on the first and last focusable nodes of the trap,\r\n    // in order to prevent focus from escaping. If it escapes for even a\r\n    // moment it can end up scrolling the page and causing confusion so we\r\n    // kind of need to capture the action at the keydown phase.\r\n    FocusTrap.prototype.checkTab = function (e) {\r\n        this.updateTabbableNodes();\r\n        if (e.shiftKey && e.target === this.state.firstTabbableNode) {\r\n            e.preventDefault();\r\n            this.tryFocus(this.state.lastTabbableNode);\r\n            return;\r\n        }\r\n        if (!e.shiftKey && e.target === this.state.lastTabbableNode) {\r\n            e.preventDefault();\r\n            this.tryFocus(this.state.firstTabbableNode);\r\n            return;\r\n        }\r\n    };\r\n    FocusTrap.prototype.checkClick = function (e) {\r\n        if (this.config.clickOutsideDeactivates)\r\n            return;\r\n        if (this.container.contains(e.target))\r\n            return;\r\n        if (this.config.allowOutsideClick && this.config.allowOutsideClick(e)) {\r\n            return;\r\n        }\r\n        e.preventDefault();\r\n        e.stopImmediatePropagation();\r\n    };\r\n    FocusTrap.prototype.updateTabbableNodes = function () {\r\n        var tabbableNodes = tabbable_1[\"default\"](this.container);\r\n        this.state.firstTabbableNode = tabbableNodes[0] || this.getInitialFocusNode();\r\n        this.state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || this.getInitialFocusNode();\r\n    };\r\n    FocusTrap.prototype.tryFocus = function (node) {\r\n        if (node === this.doc.activeElement)\r\n            return;\r\n        if (!node || !node.focus) {\r\n            this.tryFocus(this.getInitialFocusNode());\r\n            return;\r\n        }\r\n        node.focus({ preventScroll: this.config.userOptions.preventScroll });\r\n        this.state.mostRecentlyFocusedNode = node;\r\n        if (this.isSelectableInput(node)) {\r\n            node.select();\r\n        }\r\n    };\r\n    FocusTrap.prototype.isSelectableInput = function (node) {\r\n        return (node.tagName &&\r\n            node.tagName.toLowerCase() === 'input' &&\r\n            typeof node.select === 'function');\r\n    };\r\n    FocusTrap.prototype.isEscapeEvent = function (e) {\r\n        return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\r\n    };\r\n    FocusTrap.prototype.isTabEvent = function (e) {\r\n        return e.key === 'Tab' || e.keyCode === 9;\r\n    };\r\n    FocusTrap.prototype.delay = function (fn) {\r\n        return setTimeout(fn, 0);\r\n    };\r\n    return FocusTrap;\r\n}());\r\nexports[\"default\"] = FocusTrap;\r\n","var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n"],"sourceRoot":""}